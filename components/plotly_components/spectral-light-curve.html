<link rel="import" href="/bower_components/polymer/polymer-element.html">
<link rel="import" href="/imports/plotlyjs-import.html">
<link rel="import" href="/styles/plotly-style.html">

<!--<link rel="import" href = "/imports/mathJax-import.html">-->


<dom-module id="spectral-light-curve">
  <template>
    <style include="plotly-style"></style>
    <table hidden$="[[!debug]]">
      <tr>
        <td>
          <div>
            <p>Points on plot: [[countDataOnPlot]]</p>
            <!--<p>Points plotted: [[countData]]</p>-->
            <p>Classes number: [[classesnumber]]</p>
            <p>Time taken to add the LAST point: [[performanceTime]]s </p>
          </div>
        </td>
      </tr>
    </table>



    <div id="spectral-light-curve-div" style="{{stylestring}}"></div>


  </template>

  <script>

  function TraceClass(className, color){
    this.className = className;
    this.color = color;
    this.text_data = [];
    this.x_data = [];
    this.y_data = [];
    // asymmetric error bars
    this.error_x_data = [];
    this.error_x_data_minus = [];
    this.error_y_data = [];
    this.error_y_data_minus = [];
  }

  TraceClass.prototype.shiftDataArrays = function(shiftLength) {
    for(var i=0; i < shiftLength; i++){
      this.text_data.shift();
      this.x_data.shift();
      this.y_data.shift();
      this.error_x_data.shift();
      this.error_x_data_minus.shift();
      this.error_y_data.shift();
      this.error_y_data_minus.shift();
    }
  };

  TraceClass.prototype.feed = function(text, x, y, err_x, err_x_minus, err_y, err_y_minus) {
    this.text_data.push(text);
    this.x_data.push(x);
    this.y_data.push(y);
    this.error_x_data.push(err_x);
    this.error_x_data_minus.push(err_x_minus);
    this.error_y_data.push(err_y);
    this.error_y_data_minus.push(err_y_minus);
  }

  TraceClass.prototype.getTraceForPlotly = function(generalTraceLayout) {
    var _text_data = Array.from(this.text_data);
    var _x_data = Array.from(this.x_data);
    var _y_data = Array.from(this.y_data);
    var _err_x_data = Array.from(this.error_x_data);
    var _err_x_data_minus = Array.from(this.error_x_data_minus);
    var _err_y_data = Array.from(this.error_y_data);
    var _err_y_data_minus = Array.from(this.error_y_data_minus);


    var trace = JSON.parse(JSON.stringify(generalTraceLayout));

    trace["text"] = _text_data;
    trace["x"] = _x_data;
    trace["y"] = _y_data;
    trace["marker"]["color"] = this.color;

    // error bars
    trace["error_x"]["array"] = _err_x_data;
    trace["error_x"]["arrayminus"] = _err_x_data_minus;
    trace["error_x"]["color"] = this.color;

    trace["error_y"]["array"] = _err_y_data;
    trace["error_y"]["arrayminus"] = _err_y_data_minus;
    trace["error_y"]["color"] = this.color;

    return trace;

  }

    /**
     * `spectral-light-curve`
     * This element will display the spectral-light-curve plot
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class SpectralLightCurve extends Polymer.Element {

      // private properties
      constructor() {
        super();
        this.plotName = 'spectral-light-curve-div';


        this.countData = 0; // global points counter
        this.countDataOnPlot = 0; // counts the points displayed

        this.dataArrays = {};  // the keys are intergers (0,1,2...classesnumber) and the values are TraceClass containers

        this.annotations = []; // the annotations are independent from the classes

        this.performanceTime = 0;
      }

      // selector
      getPlot() { return this.shadowRoot.querySelector("#"+this.plotName); }

      // counts all the points of every container (TraceClass)
      getTotalPoints() {
        var sum = 0;
        for(var i = 0; i < this.classesnumber; i++)
            sum += this.dataArrays[i].y_data.length;
        return sum;
      }
      getClassColor(classesNumber, classIndex) {

        if ( classesNumber == 1 )
          var colors = ["#04f2f2"];    // light blue
        else if( classesNumber == 2)
          var colors = ["black", "red"];
        else if( classesNumber == 3)
          var colors = ["#04f2f2", "#f18a03", "#ef0000"]; // light blue, orange, red
        else if( classesNumber == 4)
          var colors = ["#04f2f2", "#003cef", "#f18a03", "#ef0000"]; // light blue, blue, orange, red
        else if( classesNumber == 5)
          var colors = ["#5fa815", "#003cef", "#f18a03", "#ef0000"];  // green, light blue, blue, orange, red
        else
          var colors = ["#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6"]; // all purple

        return colors[classIndex];
      }

      ready() {
        super.ready();
        this.initPlot();
      }

      initPlot() {
        this.countData = 0; // global points counter
        this.countDataOnPlot = 0; // counts the points displayed
        this.dataArrays = {};  // the keys are intergers (0,1,2...classesnumber) and the values are TraceClass containers
        this.annotations = []; // the annotations are independent from the classes
        this.performanceTime = 0;

        this.layout["annotations"];

        ////////////////////////////////////////////////////////////////////////
        // Computing colors
        var colors = [];
        for(var i = 0; i < this.classesnumber; i++)
        {
          colors.push(this.getClassColor(this.classesnumber,i));
        }

        ////////////////////////////////////////////////////////////////////////
        // Initialize the Data Arrays
        for(var i = 0; i < this.classesnumber; i++)
        {
          this.dataArrays[i] = new TraceClass(i,colors[i]);
        }

        ////////////////////////////////////////////////////////////////////////
        // Get Plotly trace objects
        var traces = [];
        for(var i = 0; i < this.classesnumber; i++)
        {
          var trace = this.dataArrays[i].getTraceForPlotly(this.generalTraceLayout);
          trace["marker"]["color"] = colors[i];
          traces.push(trace);
        }
        ////////////////////////////////////////////////////////////////////////

        // initialize the plot
        Plotly.newPlot( this.getPlot(), traces, this.layout, {scrollZoom: true});

      }


      //////////////////////////////////////////
      // PUBLIC API
      //////////////////////////////////////////

      static get is() { return 'spectral-light-curve'; }
      static get properties() {
        return {
          elemName: {
            type: String,
            value: 'light-curve'
          },
          width: {
            type: String,
            value: "400px"
          },
          height: {
            type: String,
            value: "400px"
          },
          plottitle: {
            type: String,
            value: 'Title not set'
          },
          xlabel: {
            type: String,
            value: 'Label not set',
          },
          ylabel: {
            type: String,
            value: 'Label not set',
          },
          classesnumber: {
            type: Number,
            value: 2
          },
          stylestring: {
            type: String,
            computed: 'computeStyleString(width, height)'
          },
          layout: {
            type: Object,
            computed: 'computeLayout(plottitle, xlabel, ylabel)'
          },
          generalTraceLayout: {
            type: Object,
            computed: 'computeGeneralTraceLayout()'
          },
          annotationsLayout: {
            type: Object,
            computed: 'computeAnnotationsLayout()'
          },
          debug: {
            type: Boolean,
            value: false
          }
        };
      }
      computeStyleString(width, height) {
        return "width:"+width+"; height:"+height+";"
      }
      computeLayout(plottitle, xlabel, ylabel) {
        return {
          showlegend: false,
          title: plottitle,
          xaxis: {
            title:"Energy [MeV]",
            linewidth:1,
            type: 'log',
            range: [1,5],
            ticks:"inside",
            tickvals:["10","20","30","40","50","60","70","80","90","100","200","300","400","500","600","700","800","900","1000","2000","3000","4000","5000","6000",
            "7000","8000","9000","10000","20000","30000","40000","50000","60000"],
          },
          yaxis: {
            linewidth:1,
            type: 'log',
            range: [-12, -5],
            ticks:"inside",
            tickvals:["0.0000000000001","0.0000000000002","0.0000000000003","0.0000000000004","0.0000000000005","0.0000000000006","0.0000000000007","0.0000000000008","0.0000000000009",
            "0.000000000001","0.000000000002","0.000000000003","0.000000000004","0.000000000005","0.000000000006","0.000000000007","0.000000000008","0.000000000009",
            "0.00000000001","0.00000000002","0.00000000003","0.00000000004","0.00000000005","0.00000000006","0.00000000007","0.00000000008","0.00000000009",
            "0.0000000001","0.0000000002","0.0000000003","0.0000000004","0.0000000005","0.0000000006","0.0000000007","0.0000000008","0.0000000009",
            "0.000000001","0.000000002","0.000000003","0.000000004","0.000000005","0.000000006","0.000000007","0.000000008","0.000000009",
            "0.00000001","0.00000002","0.00000003","0.00000004","0.00000005","0.00000006","0.00000007","0.00000008","0.00000009",
            "0.0000001","0.0000002","0.0000003","0.0000004","0.0000005","0.0000006","0.0000007","0.0000008","0.0000009",
            "0.000001","0.000002","0.000003","0.000004","0.000005","0.000006","0.000007","0.000008","0.000009",
            "0.00001","0.00002","0.00003","0.00004","0.00005","0.00006","0.00007","0.00008","0.00009"],
          }
        }
      }
      computeGeneralTraceLayout() {
        return {
                  mode: 'markers',
                  text: [],
                  x: [],
                  y: [],
                  marker: {
                    size:8,
                    symbol: ['circle']
                  },
                  hoverinfo: 'text',
                  type: 'scatter',
                  error_x: {
                    array: [],
                    arrayminus: [],
                    symmetric: false,
                    type: 'data',
                    visible: true,
                    width: 0,
                    thickness : 1
                  },
                  error_y: {
                    array: [],
                    arrayminus: [],
                    symmetric: false,
                    type: 'data',
                    visible: true,
                    width: 0,
                    thickness : 1
                  },
               }
      }
      computeAnnotationsLayout() {
        return {
          'xref':'x',
          'yref':'y',
          'axref':'x',
          'ayref':
          'pixel',
          'text':'',
          'showarrow':true,
          'arrowhead': 2,
          'arrowcolor':'rgb(0, 0, 0)',
          'ay': 50,
          'arrowside':'start',
          'arrowwidth':1,
        }
      }


      resetPlot() {
        this.initPlot();
      }
      setPlotTitle(title) {
        this.layout["title"] = title;
        Plotly.relayout(this.getPlot(), this.layout);

      }
      setAxisLalbes(xlabel, ylabel) {
        this.layout.xaxis["title"] = xlabel;
        this.layout.yaxis["title"] = ylabel;
        Plotly.relayout(this.getPlot(), this.layout);
      }
      setAxisTickText(xTickText, yTickText) {
        this.layout.xaxis["ticktext"] = xTickText;
        this.layout.yaxis["ticktext"] = yTickText;
      }
      setYlimits(ymin, ymax) {
        this.layout.yaxis["range"] = [ymin,ymax];
        Plotly.relayout(this.getPlot(), this.layout);
      }
      addPoint(text, x, y, err_x, err_x_min, err_y, err_y_min, addUpperLimit, pointClass) {

        // increment global counter
        this.countData += 1;

        // push the point into the container
        this.dataArrays[pointClass].feed(text, x, y, err_x, err_x_min, err_y, err_y_min);

        // update the counter of the number of points on the plot
        this.countDataOnPlot = this.getTotalPoints();

        ////////////////////////////////////////////////////////////////////////
        // Annotations (Upper Limit Arrows)
        var annotation = JSON.parse(JSON.stringify(this.annotationsLayout));

        if(addUpperLimit)
        {
          annotation["x"]  = Math.log10(x);
          annotation["y"]  = Math.log10(y);
          annotation["ax"] = Math.log10(x);
        }
        else
        {
          annotation["showarrow"] = false;
        }
        this.annotations.push(annotation);
        ////////////////////////////////////////////////////////////////////////


        ////////////////////////////////////////////////////////////////////////
        // Get Plotly trace objects
        var traces = [];
        for(var i = 0; i < this.classesnumber; i++)
        {
          var trace = this.dataArrays[i].getTraceForPlotly(this.generalTraceLayout);
          traces.push(trace);
        }
        ////////////////////////////////////////////////////////////////////////

        console.log(traces[pointClass]);

        ////////////////////////////////////////////////////////////////////////
        // Update plot
        Plotly.react(this.getPlot(), traces, this.layout);
        //https://codepen.io/etpinard/pen/QdZoQd
        //Plotly.extendTraces(this.getPlot(), {y: [[rand()], [rand()]]}, [0, 1])
        ////////////////////////////////////////////////////////////////////////

      }

    }

    window.customElements.define(SpectralLightCurve.is, SpectralLightCurve);
  </script>
</dom-module>
