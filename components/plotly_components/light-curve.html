<link rel="import" href="/bower_components/polymer/polymer-element.html">
<!--<link rel="import" href="../plotly.js/polymer-element.html">-->
<link rel="import" href="/styles/plotly-style.html">

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

<!--<link rel="import" href = "/imports/mathJax-import.html">-->

<dom-module id="light-curve">
  <template>
    <style include="plotly-style"></style>

    <div id="light-curve-div" style="{{stylestring}}"></div> <!--style="width:600px;height:400px;"-->

    <table hidden$="[[!debug]]">
      <tr>
        <td>
          <div>
            <p>Window size: [[slidingwindowsize]]</p>
            <p>Sliding window range size: ([[slidingwindowminsize]] , [[slidingwindowmaxsize]])</p>
            <p>Points on plot: [[countDataOnPlot]]</p>
            <!--<p>Points plotted: [[countData]]</p>-->
            <p>Classes number: [[classesnumber]]</p>
            <p>Time taken to add the LAST point: [[performanceTime]]s </p>
          </div>
        </td>
        <td>
          <div id="perf-graph" style="width: 480px; height: 400px;"></div>
        </td>
      </tr>
    </table>





  </template>

  <script>

  console.log(window)

  function TraceClass(className, color){
    this.className = className;
    this.color = color;
    this.text_data = [];
    this.x_data = [];
    this.y_data = [];
    // asymmetric error bars
    this.error_x_data = [];
    this.error_x_data_minus = [];
    this.error_y_data = [];
    this.error_y_data_minus = [];
  }

  TraceClass.prototype.shiftDataArrays = function(shiftLength) {
    for(var i=0; i < shiftLength; i++){
      this.text_data.shift();
      this.x_data.shift();
      this.y_data.shift();
      this.error_x_data.shift();
      this.error_x_data_minus.shift();
      this.error_y_data.shift();
      this.error_y_data_minus.shift();
    }
  };

  TraceClass.prototype.feed = function(text, x, y, err_x, err_x_minus, err_y, err_y_minus) {
    this.text_data.push(text);
    this.x_data.push(x);
    this.y_data.push(y);
    this.error_x_data.push(err_x);
    this.error_x_data_minus.push(err_x_minus);
    this.error_y_data.push(err_y);
    this.error_y_data_minus.push(err_y_minus);
  }

  TraceClass.prototype.getTraceForPlotly = function(generalTraceLayout) {
    var _text_data = Array.from(this.text_data);
    var _x_data = Array.from(this.x_data);
    var _y_data = Array.from(this.y_data);
    var _err_x_data = Array.from(this.error_x_data);
    var _err_x_data_minus = Array.from(this.error_x_data_minus);
    var _err_y_data = Array.from(this.error_y_data);
    var _err_y_data_minus = Array.from(this.error_y_data_minus);


    var trace = JSON.parse(JSON.stringify(generalTraceLayout));

    trace["text"] = _text_data;
    trace["x"] = _x_data;
    trace["y"] = _y_data;
    trace["marker"]["color"] = this.color;

    // error bars
    trace["error_x"]["array"] = _err_x_data;
    trace["error_x"]["arrayminus"] = _err_x_data_minus;
    trace["error_x"]["color"] = this.color;

    trace["error_y"]["array"] = _err_y_data;
    trace["error_y"]["arrayminus"] = _err_y_data_minus;
    trace["error_y"]["color"] = this.color;

    return trace;

  }

    /**
     * `light-curve`
     * This element will display the light-curve plot
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class LightCurve extends Polymer.Element {

      // private properties
      constructor() {
        super();
        this.plotName = 'light-curve-div';


        this.countData = 0; // global points counter
        this.countDataOnPlot = 0; // counts the points displayed

        this.dataArrays = {};  // the keys are intergers (0,1,2...classesnumber) and the values are TraceClass containers
        this.dataHistory = []; // remember in which container the data has been pushed each time

        this.annotations = []; // the annotations are independent from the classes

        this.performanceTime = 0;
      }

      // selector
      getPlot() { return this.shadowRoot.querySelector("#"+this.plotName); }
      getPerformancePlot() { return this.shadowRoot.querySelector("#perf-graph"); }
      // counts all the points of every container (TraceClass)
      getTotalPoints() {
        var sum = 0;
        for(var i = 0; i < this.classesnumber; i++)
            sum += this.dataArrays[i].y_data.length;
        return sum;
      }
      getClassColor(classesNumber, classIndex) {

        if ( classesNumber == 1 )
          var colors = ["#04f2f2"];    // light blue
        else if( classesNumber == 2)
          var colors = ["#04f2f2", "#f18a03"]; // light blue, orange
        else if( classesNumber == 3)
          var colors = ["#04f2f2", "#f18a03", "#ef0000"]; // light blue, orange, red
        else if( classesNumber == 4)
          var colors = ["#04f2f2", "#003cef", "#f18a03", "#ef0000"]; // light blue, blue, orange, red
        else if( classesNumber == 5)
          var colors = ["#5fa815", "#003cef", "#f18a03", "#ef0000"];  // green, light blue, blue, orange, red
        else
          var colors = ["#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6"]; // all purple

        return colors[classIndex];
      }

      ready() {
        super.ready();

        this.initLightCurvePlot();

        this.initPerformancePlot(true);
      }

      initLightCurvePlot() {
        this.countData = 0; // global points counter
        this.countDataOnPlot = 0; // counts the points displayed
        this.dataArrays = {};  // the keys are intergers (0,1,2...classesnumber) and the values are TraceClass containers
        this.dataHistory = []; // remember in which container the data has been pushed each time
        this.annotations = []; // the annotations are independent from the classes
        this.performanceTime = 0;

        this.layout["annotations"] = [];
        this.layout["shapes"] = [];
        ////////////////////////////////////////////////////////////////////////
        // Computing colors
        var colors = [];
        for(var i = 0; i < this.classesnumber; i++)
        {
          colors.push(this.getClassColor(this.classesnumber,i));
        }

        ////////////////////////////////////////////////////////////////////////
        // Initialize the Data Arrays
        for(var i = 0; i < this.classesnumber; i++)
        {
          this.dataArrays[i] = new TraceClass(i,colors[i]);
        }

        ////////////////////////////////////////////////////////////////////////
        // Get Plotly trace objects
        var traces = [];
        for(var i = 0; i < this.classesnumber; i++)
        {
          var trace = this.dataArrays[i].getTraceForPlotly(this.generalTraceLayout);
          trace["marker"]["color"] = colors[i];
          traces.push(trace);
        }
        ////////////////////////////////////////////////////////////////////////

        // initialize the plot
        Plotly.newPlot( this.getPlot(), traces, this.layout, {scrollZoom: true});

      }

      initPerformancePlot(isFirstLoad){
        if(this.debug)
        {
          var initData = {  x: [], y: [], text: []  };
          var layout = this.computeLayout("Performance (only points)", "", "Time for redraw [seconds]");
          layout.yaxis["range"] = [0,1];
          if(isFirstLoad)
            Plotly.newPlot(this.getPerformancePlot(), [initData], layout);
          else
            Plotly.react(this.getPerformancePlot(), [initData], layout);
        }
      }


      //////////////////////////////////////////
      // PUBLIC API
      //////////////////////////////////////////

      static get is() { return 'light-curve'; }
      static get properties() {
        return {
          elemName: {
            type: String,
            value: 'light-curve'
          },
          width: {
            type: String,
            value: "400px"
          },
          height: {
            type: String,
            value: "400px"
          },
          plottitle: {
            type: String,
            value: 'Title not set'
          },
          xlabel: {
            type: String,
            value: 'Label not set',
          },
          ylabel: {
            type: String,
            value: 'Label not set',
          },
          classesnumber: {
            type: Number,
            value: 2
          },
          slidingwindowsize: {
            type: Number,
            value: 100
          },
          slidingwindowmaxsize: {
            type: Number,
            value: 300
          },
          slidingwindowminsize: {
            type: Number,
            value: 1
          },
          stylestring: {
            type: String,
            computed: 'computeStyleString(width, height)'
          },
          layout: {
            type: Object,
            computed: 'computeLayout(plottitle, xlabel, ylabel)'
          },
          generalTraceLayout: {
            type: Object,
            computed: 'computeGeneralTraceLayout()'
          },
          annotationsLayout: {
            type: Object,
            computed: 'computeAnnotationsLayout()'
          },
          debug: {
            type: Boolean,
            value: false
          }
        };
      }
      computeStyleString(width, height) {
        return "width:"+width+"; height:"+height+";"
      }
      computeLayout(plottitle, xlabel, ylabel) {
        return {
          showlegend: false,
          title: plottitle,
          xaxis: {
            title: xlabel,
            showgrid: true,
            zeroline: true,
            showline: true,
            tickmode: 'auto',
            //tick0: 0,
            tickformat:"05.f",
            tickangle:0,
            titlefont: {
              family: 'Courier New, monospace',
              size: 18,
              color: '#7f7f7f'
            }
          },
          yaxis: {
            title: ylabel,
            showgrid: true,
            zeroline: true,
            showline: true,
            titlefont: {
              family: 'Courier New, monospace',
              size: 18,
              color: '#7f7f7f'
            }
          },
          shapes: []
        }
      }
      computeGeneralTraceLayout() {
        return {
                  mode: 'markers',
                  text: [],
                  x: [],
                  y: [],
                  marker: {
                    size:8,
                    symbol: ['circle']
                  },
                  hoverinfo: 'text',
                  type: 'scatter',
                  error_x: {
                    array: [],
                    arrayminus: [],
                    symmetric: false,
                    type: 'data',
                    visible: true,
                    width: 0,
                    thickness : 1
                  },
                  error_y: {
                    array: [],
                    arrayminus: [],
                    symmetric: false,
                    type: 'data',
                    visible: true,
                    width: 0,
                    thickness : 1
                  },
               }
      }
      computeAnnotationsLayout() {
        return {
                'xref':'x',
                'yref':'y',
                'axref':'x',
                'ayref':'pixel',
                'text':'',
                'showarrow':true,
                'arrowhead': 2,
                'arrowsize': 1,
                'arrowwidth': 1,
                'arrowcolor': 'rgb(0, 0, 0)',
                'ay':50,
                'borderwidth': 0,
                'borderpad': 0,
                'arrowside':'start'
              }
      }

      resetPlot() {
        this.initLightCurvePlot();
        this.initPerformancePlot(true);
      }

      setPlotTitle(title) {
        this.layout["title"] = title;
        Plotly.relayout(this.getPlot(), this.layout);

      }
      setAxisLalbes(xlabel, ylabel) {
        this.layout.xaxis["title"] = xlabel;
        this.layout.yaxis["title"] = ylabel;
        Plotly.relayout(this.getPlot(), this.layout);
      }

      setYlimits(ymin, ymax) {
        this.layout.yaxis["range"] = [ymin - (ymin*10/100),ymax + (ymax*10/100)];
        Plotly.relayout(this.getPlot(), this.layout);
      }

      setTickDistance(dTick) {
        this.layout.xaxis["tickmode"] = 'linear';
        this.layout.xaxis["tick0"] = 0;
        this.layout.xaxis["dtick"] = dTick;
        Plotly.relayout(this.getPlot(), this.layout);
      }
      setTickAutoMode() {
        this.layout.xaxis["tickmode"] = 'auto';
        delete this.layout.xaxis.tick0;
        delete this.layout.xaxis.dtick;
        Plotly.relayout(this.getPlot(), this.layout);
      }

      addLine(x0,y0,x1,y1,color,width,dashType) {
        this.layout["shapes"].push({
                                    type: 'line',
                                    x0: x0,
                                    y0: y0,
                                    x1: x1,
                                    y1: y1,
                                    xref: 'paper',
                                    line: {
                                      color: color,
                                      width: width,
                                      dash: dashType
                                    }
                                  })
      }

      addPoint(text, x, y, err_x, err_x_min, err_y, err_y_min, addUpperLimit, pointClass) {
        var t0 = performance.now();

        // increment global counter
        this.countData += 1;

        // save the container in which the point is pushed to
        this.dataHistory.push(pointClass);

        // push the point into the container
        this.dataArrays[pointClass].feed(text, x, y, err_x, err_x_min, err_y, err_y_min);

        ////////////////////////////////////////////////////////////////////////
        // Sliding Window for points
        var totalPointsOnWindow = this.getTotalPoints();

        if(totalPointsOnWindow > this.slidingwindowsize)
        {
            var numberOfPointsToRemove = totalPointsOnWindow - this.slidingwindowsize;

            // removing points from the containers with a last-in first-out politic
            for(var i=0; i < numberOfPointsToRemove; i++)
            {
              var removeFromContainerId = this.dataHistory.shift(); // get first (oldest) container
              this.dataArrays[removeFromContainerId].shiftDataArrays(1);
            }
        }
        ////////////////////////////////////////////////////////////////////////


        // update the counter of the number of points on the plot
        this.countDataOnPlot = this.getTotalPoints();


        ////////////////////////////////////////////////////////////////////////
        // Annotations (Upper Limit Arrows)
        var annotation = JSON.parse(JSON.stringify(this.annotationsLayout));

        if(addUpperLimit)
        {
          annotation["x"]  = x;
          annotation["y"]  = y;
          annotation["ax"] = x;
        }
        else
        {
          annotation["showarrow"] = false;
        }
        this.annotations.push(annotation);
        ////////////////////////////////////////////////////////////////////////


        ////////////////////////////////////////////////////////////////////////
        // Sliding Window for annotations
        if(this.annotations.length > this.slidingwindowsize)
        {
          var offset = this.annotations.length - this.slidingwindowsize;
          for(var i=0; i < offset; i++)
          {
            this.annotations.shift();
          }
        }
        var _annotations = Array.from(this.annotations);
        this.layout["annotations"] = _annotations;
        ////////////////////////////////////////////////////////////////////////



        ////////////////////////////////////////////////////////////////////////
        // Get Plotly trace objects
        var traces = [];
        for(var i = 0; i < this.classesnumber; i++)
        {
          var trace = this.dataArrays[i].getTraceForPlotly(this.generalTraceLayout);
          traces.push(trace);
        }
        ////////////////////////////////////////////////////////////////////////

        console.log(traces[pointClass]);

        ////////////////////////////////////////////////////////////////////////
        // Update plot
        Plotly.react(this.getPlot(), traces, this.layout);
        //https://codepen.io/etpinard/pen/QdZoQd
        //Plotly.extendTraces(this.getPlot(), {y: [[rand()], [rand()]]}, [0, 1])
        ////////////////////////////////////////////////////////////////////////

        var t1 = performance.now();
        this.performanceTime = ((t1 - t0)/1000).toFixed(5);
        if(this.debug)
        {
          Plotly.extendTraces(this.getPerformancePlot(), {
            x: [[this.countData]],
            y: [[this.performanceTime]],
            text: [[this.countDataOnPlot]]
          }, [0])
        }
      }



      increaseSlidingWindowSize() {
        if( this.slidingwindowsize < this.slidingwindowmaxsize)
        {
          this.slidingwindowsize += 1;
          //this.initPerformancePlot(false);
        }
      }

      decreaseSlidingWindowSize() {
        if(this.slidingwindowsize > this.slidingwindowminsize)
        {
          this.slidingwindowsize -= 1;
          //this.initPerformancePlot(false);
        }
      }

      setMaxSlidingWindowSize() {
        this.slidingwindowsize = this.slidingwindowmaxsize;
        //this.initPerformancePlot(false);
      }
      setMinSlidingWindowSize() {
        this.slidingwindowsize = this.slidingwindowminsize;
        //this.initPerformancePlot(false);
      }

    }

    window.customElements.define(LightCurve.is, LightCurve);
  </script>
</dom-module>
