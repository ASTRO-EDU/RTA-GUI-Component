<link rel="import" href="/bower_components/polymer/polymer-element.html">
<!--<link rel="import" href="../plotly.js/polymer-element.html">-->
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>





<dom-module id="light-curve">
  <template>
    <style>
    .js-plotly-plot .plotly, .js-plotly-plot .plotly div {
         font-family:'Open Sans', verdana, arial, sans-serif;
         margin:0;
         padding:0;
     }

     .js-plotly-plot .plotly input, .js-plotly-plot .plotly button {
         font-family:'Open Sans', verdana, arial, sans-serif;
     }

     .js-plotly-plot .plotly input:focus,.js-plotly-plot .plotly button:focus {
         outline:none;
     }

     .js-plotly-plot .plotly a {
         text-decoration:none;
     }

     .js-plotly-plot .plotly a:hover {
         text-decoration:none;
     }

     .js-plotly-plot .plotly .crisp {
         shape-rendering:crispEdges;
     }

     .js-plotly-plot .plotly .user-select-none {
         -webkit-user-select:none;
         -moz-user-select:none;
         -ms-user-select:none;
         -o-user-select:none;
         user-select:none;
     }

     .js-plotly-plot .plotly svg {
         overflow:hidden;
     }

     .js-plotly-plot .plotly svg a {
         fill:#447adb;
     }

     .js-plotly-plot .plotly svg a:hover {
         fill:#3c6dc5;
     }

     .js-plotly-plot .plotly .main-svg {
         position:absolute;
         top:0;
         left:0;
         pointer-events:none;
     }

     .js-plotly-plot .plotly .main-svg .draglayer {
         pointer-events:all;
     }

     .js-plotly-plot .plotly .cursor-default {
         cursor:default;
     }

     .js-plotly-plot .plotly .cursor-pointer {
         cursor:pointer;
     }

     .js-plotly-plot .plotly .cursor-crosshair {
         cursor:crosshair;
     }

     .js-plotly-plot .plotly .cursor-move {
         cursor:move;
     }

     .js-plotly-plot .plotly .cursor-col-resize {
         cursor:col-resize;
     }

     .js-plotly-plot .plotly .cursor-row-resize {
         cursor:row-resize;
     }

     .js-plotly-plot .plotly .cursor-ns-resize {
         cursor:ns-resize;
     }

     .js-plotly-plot .plotly .cursor-ew-resize {
         cursor:ew-resize;
     }

     .js-plotly-plot .plotly .cursor-sw-resize {
         cursor:sw-resize;
     }

     .js-plotly-plot .plotly .cursor-s-resize {
         cursor:s-resize;
     }

     .js-plotly-plot .plotly .cursor-se-resize {
         cursor:se-resize;
     }

     .js-plotly-plot .plotly .cursor-w-resize {
         cursor:w-resize;
     }

     .js-plotly-plot .plotly .cursor-e-resize {
         cursor:e-resize;
     }

     .js-plotly-plot .plotly .cursor-nw-resize {
         cursor:nw-resize;
     }

     .js-plotly-plot .plotly .cursor-n-resize {
         cursor:n-resize;
     }

     .js-plotly-plot .plotly .cursor-ne-resize {
         cursor:ne-resize;
     }

     .js-plotly-plot .plotly .modebar {
         position:absolute;
         top:2px;
         right:2px;
         z-index:1001;
         background:rgba(255,255,255,0.7);
     }

     .js-plotly-plot .plotly .modebar--hover {
         opacity:0;
         -webkit-transition:opacity 0.3s ease 0s;
         -moz-transition:opacity 0.3s ease 0s;
         -ms-transition:opacity 0.3s ease 0s;
         -o-transition:opacity 0.3s ease 0s;
         transition:opacity 0.3s ease 0s;
     }

     .js-plotly-plot .plotly:hover .modebar--hover {
         opacity:1;
     }

     .js-plotly-plot .plotly .modebar-group {
         float:left;
         display:inline-block;
         box-sizing:border-box;
         margin-left:8px;
         position:relative;
         vertical-align:middle;
         white-space:nowrap;
     }

     .js-plotly-plot .plotly .modebar-group:first-child {
         margin-left:0px;
     }

     .js-plotly-plot .plotly .modebar-btn {
         position:relative;
         font-size:16px;
         padding:3px 4px;
         cursor:pointer;
         line-height:normal;
         box-sizing:border-box;
     }

     .js-plotly-plot .plotly .modebar-btn svg {
         position:relative;
         top:2px;
     }

     .js-plotly-plot .plotly .modebar-btn path {
         fill:rgba(0,31,95,0.3);
     }

     .js-plotly-plot .plotly .modebar-btn.active path,.js-plotly-plot .plotly .modebar-btn:hover path {
         fill:rgba(0,22,72,0.5);
     }

     .js-plotly-plot .plotly .modebar-btn.modebar-btn--logo {
         padding:3px 1px;
     }

     .js-plotly-plot .plotly .modebar-btn.modebar-btn--logo path {
         fill:#447adb !important;
     }

     .js-plotly-plot .plotly [data-title]:before,.js-plotly-plot .plotly [data-title]:after {
         position:absolute;
         -webkit-transform:translate3d(0, 0, 0);
         -moz-transform:translate3d(0, 0, 0);
         -ms-transform:translate3d(0, 0, 0);
         -o-transform:translate3d(0, 0, 0);
         transform:translate3d(0, 0, 0);
         display:none;
         opacity:0;
         z-index:1001;
         pointer-events:none;
         top:110%;
         right:50%;
     }

     .js-plotly-plot .plotly [data-title]:hover:before,.js-plotly-plot .plotly [data-title]:hover:after {
         display:block;
         opacity:1;
     }

     .js-plotly-plot .plotly [data-title]:before {
         content:'';
         position:absolute;
         background:transparent;
         border:6px solid transparent;
         z-index:1002;
         margin-top:-12px;
         border-bottom-color:#69738a;
         margin-right:-6px;
     }

     .js-plotly-plot .plotly [data-title]:after {
         content:attr(data-title);
         background:#69738a;
         color:white;
         padding:8px 10px;
         font-size:12px;
         line-height:12px;
         white-space:nowrap;
         margin-right:-18px;
         border-radius:2px;
     }

     .js-plotly-plot .plotly .select-outline {
         fill:none;
         stroke-width:1;
         shape-rendering:crispEdges;
     }

     .js-plotly-plot .plotly .select-outline-1 {
         stroke:white;
     }

     .js-plotly-plot .plotly .select-outline-2 {
         stroke:black;
         stroke-dasharray:2px 2px;
     }

     .plotly-notifier {
         font-family:'Open Sans';
         position:fixed;
         top:50px;
         right:20px;
         z-index:10000;
         font-size:10pt;
         max-width:180px;
     }

     .plotly-notifier p {
         margin:0;
     }

     .plotly-notifier .notifier-note {
         min-width:180px;
         max-width:250px;
         border:1px solid #fff;
         z-index:3000;
         margin:0;
         background-color:#8c97af;
         background-color:rgba(140,151,175,0.9);
         color:#fff;
         padding:10px;
     }

     .plotly-notifier .notifier-close {
         color:#fff;
         opacity:0.8;
         float:right;
         padding:0 5px;
         background:none;
         border:none;
         font-size:20px;
         font-weight:bold;
         line-height:20px;
     }

     .plotly-notifier .notifier-close:hover {
         color:#444;
         text-decoration:none;
         cursor:pointer;
     }
    </style>
    <h2>[[elemName]]</h2>
    <table hidden$="[[!debug]]">
      <tr>
        <td>
          <div>
            <p>Window size: [[slidingwindowsize]]</p>
            <p>Sliding window range size: ([[slidingwindowminsize]] , [[slidingwindowmaxsize]])</p>
            <p>Points on plot: [[countDataOnPlot]]</p>
            <!--<p>Points plotted: [[countData]]</p>-->
            <p>Classes number: [[classesnumber]]</p>
            <p>Time taken to add the LAST point: [[performanceTime]]s </p>
          </div>
        </td>
        <td>
          <div id="perf-graph" style="width: 480px; height: 400px;"></div>
        </td>
      </tr>
    </table>



    <div id="light-curve-div" style="{{stylestring}}"></div> <!--style="width:600px;height:400px;"-->


  </template>

  <script>

  function TraceClass(className, color){
    this.className = className;
    this.color = color;
    this.text_data = [];
    this.x_data = [];
    this.y_data = [];
    // asymmetric error bars
    this.error_x_data = [];
    this.error_x_data_minus = [];
    this.error_y_data = [];
    this.error_y_data_minus = [];
  }

  TraceClass.prototype.shiftDataArrays = function(shiftLength) {
    for(var i=0; i < shiftLength; i++){
      this.text_data.shift();
      this.x_data.shift();
      this.y_data.shift();
      this.error_x_data.shift();
      this.error_x_data_minus.shift();
      this.error_y_data.shift();
      this.error_y_data_minus.shift();
    }
  };

  TraceClass.prototype.feed = function(text, x, y, err_x, err_x_minus, err_y, err_y_minus) {
    this.text_data.push(text);
    this.x_data.push(x);
    this.y_data.push(y);
    this.error_x_data.push(err_x);
    this.error_x_data_minus.push(err_x_minus);
    this.error_y_data.push(err_y);
    this.error_y_data_minus.push(err_y_minus);
  }

  TraceClass.prototype.getTraceForPlotly = function(generalTraceLayout) {
    var _text_data = Array.from(this.text_data);
    var _x_data = Array.from(this.x_data);
    var _y_data = Array.from(this.y_data);
    var _err_x_data = Array.from(this.error_x_data);
    var _err_x_data_minus = Array.from(this.error_x_data_minus);
    var _err_y_data = Array.from(this.error_y_data);
    var _err_y_data_minus = Array.from(this.error_y_data_minus);


    var trace = JSON.parse(JSON.stringify(generalTraceLayout));

    trace["text"] = _text_data;
    trace["x"] = _x_data;
    trace["y"] = _y_data;
    trace["marker"]["color"] = this.color;

    // error bars
    trace["error_x"]["array"] = _err_x_data;
    trace["error_x"]["arrayminus"] = _err_x_data_minus;
    trace["error_x"]["color"] = this.color;

    trace["error_y"]["array"] = _err_y_data;
    trace["error_y"]["arrayminus"] = _err_y_data_minus;
    trace["error_y"]["color"] = this.color;

    return trace;

  }

    /**
     * `light-curve`
     * This element will display the light-curve plot
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class LightCurve extends Polymer.Element {

      // private properties
      constructor() {
        super();
        this.plotName = 'light-curve-div';


        this.countData = 0; // global points counter
        this.countDataOnPlot = 0; // counts the points displayed

        this.dataArrays = {};  // the keys are intergers (0,1,2...classesnumber) and the values are TraceClass containers
        this.dataHistory = []; // remember in which container the data has been pushed each time

        this.annotations = []; // the annotations are independent from the classes

        this.performanceTime = 0;
      }

      // selector
      getPlot() { return this.shadowRoot.querySelector("#"+this.plotName); }
      getPerformancePlot() { return this.shadowRoot.querySelector("#perf-graph"); }
      // counts all the points of every container (TraceClass)
      getTotalPoints() {
        var sum = 0;
        for(var i = 0; i < this.classesnumber; i++)
            sum += this.dataArrays[i].y_data.length;
        return sum;
      }
      getClassColor(classesNumber, classIndex) {

        if ( classesNumber == 1 )
          var colors = ["#04f2f2"];    // light blue
        else if( classesNumber == 2)
          var colors = ["#04f2f2", "#f18a03"]; // light blue, orange
        else if( classesNumber == 3)
          var colors = ["#04f2f2", "#f18a03", "#ef0000"]; // light blue, orange, red
        else if( classesNumber == 4)
          var colors = ["#04f2f2", "#003cef", "#f18a03", "#ef0000"]; // light blue, blue, orange, red
        else if( classesNumber == 5)
          var colors = ["#5fa815", "#003cef", "#f18a03", "#ef0000"];  // green, light blue, blue, orange, red
        else
          var colors = ["#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6","#f700d6"]; // all purple

        return colors[classIndex];
      }

      ready() {
        super.ready();

        this.initLightCurvePlot();

        this.initPerformancePlot(true);
      }

      initLightCurvePlot() {
        this.countData = 0; // global points counter
        this.countDataOnPlot = 0; // counts the points displayed
        this.dataArrays = {};  // the keys are intergers (0,1,2...classesnumber) and the values are TraceClass containers
        this.dataHistory = []; // remember in which container the data has been pushed each time
        this.annotations = []; // the annotations are independent from the classes
        this.performanceTime = 0;
        
        this.layout["annotations"];
        ////////////////////////////////////////////////////////////////////////
        // Computing colors
        var colors = [];
        for(var i = 0; i < this.classesnumber; i++)
        {
          colors.push(this.getClassColor(this.classesnumber,i));
        }

        ////////////////////////////////////////////////////////////////////////
        // Initialize the Data Arrays
        for(var i = 0; i < this.classesnumber; i++)
        {
          this.dataArrays[i] = new TraceClass(i,colors[i]);
        }

        ////////////////////////////////////////////////////////////////////////
        // Get Plotly trace objects
        var traces = [];
        for(var i = 0; i < this.classesnumber; i++)
        {
          var trace = this.dataArrays[i].getTraceForPlotly(this.generalTraceLayout);
          trace["marker"]["color"] = colors[i];
          traces.push(trace);
        }
        ////////////////////////////////////////////////////////////////////////

        // initialize the plot
        Plotly.newPlot( this.getPlot(), traces, this.layout, {scrollZoom: true});

      }

      initPerformancePlot(isFirstLoad){
        if(this.debug)
        {
          var initData = {  x: [], y: [], text: []  };
          if(isFirstLoad)
            Plotly.newPlot(this.getPerformancePlot(), [initData], this.computeLayout("Performance (only points)", "Points to be displayed", "Seconds"));
          else
            Plotly.react(this.getPerformancePlot(), [initData], this.computeLayout("Performance (only points)", "Points to be displayed", "Seconds"));
        }
      }

      resetPlot() {
        this.initLightCurvePlot();
        this.initPerformancePlot(true);
      }
      //////////////////////////////////////////
      // PUBLIC API
      //////////////////////////////////////////

      static get is() { return 'light-curve'; }
      static get properties() {
        return {
          elemName: {
            type: String,
            value: 'light-curve'
          },
          width: {
            type: String,
            value: "400px"
          },
          height: {
            type: String,
            value: "400px"
          },
          plottitle: {
            type: String,
            value: 'Title not set'
          },
          xlabel: {
            type: String,
            value: 'Label not set',
          },
          ylabel: {
            type: String,
            value: 'Label not set',
          },
          classesnumber: {
            type: Number,
            value: 2
          },
          slidingwindowsize: {
            type: Number,
            value: 100
          },
          slidingwindowmaxsize: {
            type: Number,
            value: 300
          },
          slidingwindowminsize: {
            type: Number,
            value: 1
          },
          stylestring: {
            type: String,
            computed: 'computeStyleString(width, height)'
          },
          layout: {
            type: Object,
            computed: 'computeLayout(plottitle, xlabel, ylabel)'
          },
          generalTraceLayout: {
            type: Object,
            computed: 'computeGeneralTraceLayout()'
          },
          annotationsLayout: {
            type: Object,
            computed: 'computeAnnotationsLayout()'
          },
          debug: {
            type: Boolean,
            value: false
          }
        };
      }
      computeStyleString(width, height) {
        return "width:"+width+"; height:"+height+";"
      }
      computeLayout(plottitle, xlabel, ylabel) {
        return {
          showlegend: false,
          title: plottitle,
          xaxis: {
            title: xlabel,
            showgrid: true,
            zeroline: true,
            showline: true,
            tickformat:"05.f",
            tickangle:0,
            titlefont: {
              family: 'Courier New, monospace',
              size: 18,
              color: '#7f7f7f'
            }
          },
          yaxis: {
            title: ylabel,
            showgrid: true,
            zeroline: true,
            showline: true,
            titlefont: {
              family: 'Courier New, monospace',
              size: 18,
              color: '#7f7f7f'
            }
          }
        }
      }
      computeGeneralTraceLayout() {
        return {
                  mode: 'markers',
                  text: [],
                  x: [],
                  y: [],
                  marker: {
                    size:8,
                    symbol: ['circle']
                  },
                  hoverinfo: 'text',
                  type: 'scatter',
                  error_x: {
                    array: [],
                    arrayminus: [],
                    symmetric: false,
                    type: 'data',
                    visible: true,
                    width: 0,
                    thickness : 1
                  },
                  error_y: {
                    array: [],
                    arrayminus: [],
                    symmetric: false,
                    type: 'data',
                    visible: true,
                    width: 0,
                    thickness : 1
                  },
               }
      }
      computeAnnotationsLayout() {
        return {
                'xref':'x',
                'yref':'y',
                'axref':'x',
                'ayref':'pixel',
                'text':'',
                'showarrow':true,
                'arrowhead': 2,
                'arrowsize': 1,
                'arrowwidth': 1,
                'arrowcolor': 'rgb(0, 0, 0)',
                'ay':50,
                'borderwidth': 0,
                'borderpad': 0,
                'arrowside':'start'
              }
      }

      setYlimits(ymin, ymax) {
        this.layout.yaxis["range"] = [ymin - (ymin*10/100),ymax + (ymax*10/100)];
      }

      addPoint(text, x, y, err_x, err_x_min, err_y, err_y_min, addUpperLimit, pointClass) {
        var t0 = performance.now();

        // increment global counter
        this.countData += 1;

        // save the container in which the point is pushed to
        this.dataHistory.push(pointClass);

        // push the point into the container
        this.dataArrays[pointClass].feed(text, x, y, err_x, err_x_min, err_y, err_y_min);

        ////////////////////////////////////////////////////////////////////////
        // Sliding Window for points
        var totalPointsOnWindow = this.getTotalPoints();

        if(totalPointsOnWindow > this.slidingwindowsize)
        {
            var numberOfPointsToRemove = totalPointsOnWindow - this.slidingwindowsize;

            // removing points from the containers with a last-in first-out politic
            for(var i=0; i < numberOfPointsToRemove; i++)
            {
              var removeFromContainerId = this.dataHistory.shift(); // get first (oldest) container
              this.dataArrays[removeFromContainerId].shiftDataArrays(1);
            }
        }
        ////////////////////////////////////////////////////////////////////////


        // update the counter of the number of points on the plot
        this.countDataOnPlot = this.getTotalPoints();


        ////////////////////////////////////////////////////////////////////////
        // Annotations (Upper Limit Arrows)
        var annotation = JSON.parse(JSON.stringify(this.annotationsLayout));

        if(addUpperLimit)
        {
          annotation["x"]  = x;
          annotation["y"]  = y;
          annotation["ax"] = x;
        }
        else
        {
          annotation["showarrow"] = false;
        }
        this.annotations.push(annotation);
        ////////////////////////////////////////////////////////////////////////


        ////////////////////////////////////////////////////////////////////////
        // Sliding Window for annotations
        if(this.annotations.length > this.slidingwindowsize)
        {
          var offset = this.annotations.length - this.slidingwindowsize;
          for(var i=0; i < offset; i++)
          {
            this.annotations.shift();
          }
        }
        var _annotations = Array.from(this.annotations);
        this.layout["annotations"] = _annotations;
        ////////////////////////////////////////////////////////////////////////



        ////////////////////////////////////////////////////////////////////////
        // Get Plotly trace objects
        var traces = [];
        for(var i = 0; i < this.classesnumber; i++)
        {
          var trace = this.dataArrays[i].getTraceForPlotly(this.generalTraceLayout);
          traces.push(trace);
        }
        ////////////////////////////////////////////////////////////////////////

        console.log(traces[pointClass]);

        ////////////////////////////////////////////////////////////////////////
        // Update plot
        Plotly.react(this.getPlot(), traces, this.layout);
        //https://codepen.io/etpinard/pen/QdZoQd
        //Plotly.extendTraces(this.getPlot(), {y: [[rand()], [rand()]]}, [0, 1])
        ////////////////////////////////////////////////////////////////////////

        var t1 = performance.now();
        this.performanceTime = ((t1 - t0)/1000).toFixed(5);
        if(this.debug)
        {
          Plotly.extendTraces(this.getPerformancePlot(), {
            x: [[this.countData]],
            y: [[this.performanceTime]],
            text: [[this.countDataOnPlot]]
          }, [0])
        }
      }



      increaseSlidingWindowSize() {
        if( this.slidingwindowsize < this.slidingwindowmaxsize)
        {
          this.slidingwindowsize += 1;
          //this.initPerformancePlot(false);
        }
      }

      decreaseSlidingWindowSize() {
        if(this.slidingwindowsize > this.slidingwindowminsize)
        {
          this.slidingwindowsize -= 1;
          //this.initPerformancePlot(false);
        }
      }

      setMaxSlidingWindowSize() {
        this.slidingwindowsize = this.slidingwindowmaxsize;
        //this.initPerformancePlot(false);
      }
      setMinSlidingWindowSize() {
        this.slidingwindowsize = this.slidingwindowminsize;
        //this.initPerformancePlot(false);
      }

    }

    window.customElements.define(LightCurve.is, LightCurve);
  </script>
</dom-module>
